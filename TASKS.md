# Initial Development Tasks

This document captures recommended starting tasks for building out the text-adventure agent framework. Items are grouped by priority so we can tackle the highest-impact work first.

## Priority 0: Environment Baseline
- [x] Create a minimal `src/main.py` entry point that can be executed after dependency installation.
- [x] Configure a package structure under `src/` (e.g., `src/textadventure/__init__.py`).
- [x] Add basic test scaffolding in `tests/` (at least one placeholder test verifying the package imports).
- [x] Confirm linting and formatting commands (`black`, `ruff`) run cleanly on the scaffolded code. *(Added `pytest.ini` to expose the `src/` layout and reformatted existing modules so Black and Ruff both pass.)*

## Priority 1: Core Framework Skeleton
- [x] Implement a `WorldState` object responsible for tracking locations, inventory, and history.
- [x] Design an interface for a `StoryEngine` component that can propose narrative events based on the world state.
- [x] Provide an abstraction around LLM calls (e.g., `LLMClient`) that can be mocked during tests.
- [x] Draft a simple command loop (CLI) that takes player input and routes it through the story engine.
- [x] Create an initial concrete `StoryEngine` implementation that returns scripted events for testing the loop.

## Priority 2: Persistence & Memory
- [x] Define how game sessions will be persisted (in-memory first, followed by optional file-based persistence).
- [x] Introduce a lightweight memory mechanism so the agent can recall past actions and player choices. *(Implemented `MemoryLog` utilities, wired into the world state, and surfaced via a scripted "recall" command.)*

## Priority 3: Testing & Tooling Enhancements
- [x] Write unit tests covering the world state mutations and narrative branching logic.
- [x] Set up fixtures or mocks for LLM interactions to keep tests deterministic. *(Added reusable `MockLLMClient` pytest fixtures for queuing scripted responses.)*
- [x] Integrate static type checking with `mypy` and document the workflow. *(Added `mypy.ini`, updated developer docs, and
  tracked the dependency in `requirements.txt`. Setting up CI remains a future improvement.)*
- [x] Add smoke tests for the CLI once the interactive loop is implemented. *(Introduced `tests/test_cli.py` to simulate player commands and verify graceful termination scenarios.)*

## Priority 4: Stretch Goals
- [x] Explore integrating external tools (e.g., knowledge bases or calculators) the agent can invoke during gameplay.
  - [x] Define a lightweight tool abstraction and document how tools are registered with a story engine.
  - [x] Provide an initial knowledge-base tool that surfaces lore lookups through scripted commands.
  - [x] Add automated tests covering the new tool flow and update user-facing guidance where appropriate.
- [x] Investigate saving/loading checkpoints for long-running adventures.
  - [x] Add CLI commands to save and load sessions using the persistence layer.
  - [x] Extend persistence snapshots to cover memory and provide helpers for applying them.
  - [x] Add automated tests demonstrating a save/load round-trip through the CLI.
- [x] Evaluate multi-agent orchestration for NPC behaviors or parallel storylines.
  - [x] Survey the existing single-agent architecture to identify integration points for orchestrating multiple agents.
  - [x] Draft a design proposal describing a coordinator component, message flows, and how NPC agents might plug into the story engine.
  - [x] Prototype the coordinator interfaces and stub implementations to validate the design with the scripted engine. *(Added a `MultiAgentCoordinator` with a `ScriptedStoryAgent` adapter and regression tests covering secondary narration merging.)*
  - [x] Extend the coordinator to route queued agent messages between turns once richer NPC behaviour is introduced. *(Coordinator now drains message queues each turn, targets recipients, and defers newly queued triggers to the following round with regression coverage.)*
  - [x] Outline testing strategies (unit and integration) to ensure deterministic behaviour with multiple agents. *(Documented layered unit, integration, and tooling plans in `docs/multi_agent_orchestration.md`.)*

Revisit this backlog as soon as the initial scaffolding is in place so we can refine upcoming milestones based on early feedback.

## Priority 5: Data-Driven Narrative Expansion
- [x] Externalise the scripted scenes into structured data files (e.g., YAML or JSON) so adventures can be edited without touching code while retaining sensible defaults for the demo.
  - [x] Extract the current hard-coded demo scenes into a reusable data file checked into the repo.
  - [x] Update `ScriptedStoryEngine` so it can load scenes from structured data and still provide a default demo set.
  - [x] Refresh tests and docs to cover the data-driven scene workflow.
- [x] Add validation helpers that load the scene definitions, ensure commands are unique, verify transition targets exist, and surface descriptive errors with unit tests.
  - [x] Add validation checks for duplicate choice commands and unknown transition targets when loading scenes.
  - [x] Cover validation failure scenarios with dedicated unit tests.
- [x] Document the data format and authoring workflow in `docs/` and update the README so contributors can build new adventures quickly. *(Added `docs/data_driven_scenes.md` and linked guidance from the README.)*

## Priority 6: Generative Agent Integration
- [x] Implement an `LLMStoryAgent` that wraps `LLMClient`, assembles prompts from the world state, and can participate in the `MultiAgentCoordinator` turn loop.
  - [x] Build a structured prompt generator that summarises the world state and trigger context for the LLM.
  - [x] Parse JSON responses from the LLM into `StoryEvent` instances with validation.
  - [x] Cover the agent with unit tests demonstrating prompt construction and error handling.
- [x] Extend the memory system so agents can request recent observations/actions as part of their prompts, with configuration for how much history to include. *(Added `MemoryRequest` for triggers, debug visibility, and overrides in `LLMStoryAgent` with regression tests.)*
- [x] Provide integration tests (or golden transcripts) that exercise a hybrid scripted + LLM-backed coordinator using deterministic fixtures.
  - [x] Add an integration test that runs the multi-agent coordinator with the scripted primary agent and an LLM-driven secondary agent, asserting the merged narration, choices, and metadata.

## Priority 7: Observability & Tooling
- [x] Add transcript logging options to the CLI (e.g., `--log-file`) that capture narration, player input, and agent metadata for debugging sessions.
  - [x] Outline transcript logging format and captured fields.
  - [x] Implement the CLI `--log-file` flag with a structured transcript writer.
  - [x] Add regression tests and documentation covering the logging workflow.
- [x] Introduce a debug command (such as `status`) that prints the active location, inventory summary, queued agent messages, and pending saves.
  - [x] Provide a coordinator debug snapshot with visibility into queued messages.
  - [x] Surface the world/persistence details through a CLI `status` command and cover it with tests.
- [x] Set up a continuous integration workflow (GitHub Actions) to run tests, type checks, and linting on each push. *(Added a GitHub Actions pipeline executing pytest, mypy, Ruff, and Black on pushes and pull requests.)*

## Priority 8: LLM Framework Integrations
- [x] Expand the generic `LLMClient` abstraction so it can expose provider capabilities (streaming, function calling, tool APIs) in a uniform schema across integrations.
  - [x] Define capability data structures capturing streaming, function-calling, and tool invocation metadata in a reusable format.
  - [x] Extend the `LLMClient` interface to surface capabilities and update existing implementations/mocks to advertise their support levels.
  - [x] Add unit tests covering capability negotiation to ensure providers gracefully degrade when a feature is unsupported.
  - [x] Document the canonical interface in developer docs and surface configuration examples for advanced options like temperature, caching, and safety filters.
- [x] Implement adapters for popular online providers (e.g., OpenAI, Anthropic, Cohere) that wrap their SDKs and map responses to the generic interface.
  - [x] Implement an OpenAI chat completion adapter that conforms to ``LLMClient``.
  - [x] Implement an Anthropic messages adapter that conforms to ``LLMClient``.
  - [x] Implement a Cohere chat adapter that conforms to ``LLMClient``.
  - [x] Cover the new adapters with targeted unit tests and usage documentation.
- [x] Provide retry, rate limiting, and error classification helpers that can be reused across adapters.
  - [x] Define reusable error categories and a classifier utility for mapping provider exceptions.
  - [x] Implement a configurable retry policy with exponential backoff and optional jitter.
  - [x] Add a shared fixed-interval rate limiter that adapters can reuse to throttle requests.
  - [x] Cover the new helpers with deterministic unit tests.
- [x] Add integration tests using recorded responses or fixtures to validate prompt/response translation and error handling.
  - [x] Replay recorded transcript fixtures to assert prompts, choices, and metadata merge correctly.
  - [x] Cover misconfigured fixture payloads to verify descriptive error handling from LLMStoryAgent.
- [x] Implement adapters for local runtimes (e.g., Hugging Face Text Generation Inference, llama.cpp servers) so self-hosted models can plug into the same flow.
  - [x] Document setup instructions and configuration flags required to target each local runtime.
  - [x] Add smoke tests or mocks verifying adapters handle streaming, chunked responses, and offline failure scenarios.
- [x] Create a provider registry that loads adapters dynamically based on configuration files or CLI options.
  - [x] Define an `LLMProviderRegistry` that handles registering and resolving provider factories.
  - [x] Support instantiating providers from configuration mappings (e.g., parsed config files).
  - [x] Support instantiating providers from CLI-style option strings for manual selection.
  - [x] Cover the registry behaviour with automated tests, including dynamic import and error handling.
  - [x] Update the CLI and coordinator wiring so adventures can select LLM providers at runtime.
    - [x] Add CLI flags for selecting an LLM provider and passing option key/value pairs.
    - [x] Instantiate LLM-backed agents via the provider registry when configured and integrate them with the coordinator.
    - [x] Document the workflow and add regression tests covering provider selection.
  - [x] Ensure registry lookups and adapter instantiation are covered by tests, including misconfiguration handling. *(Added coverage for dynamic import errors, invalid identifiers, and duplicate CLI options to assert descriptive failures.)*
  - [x] Support loading provider configuration from JSON files and exposing a matching CLI flag. *(Added `LLMProviderRegistry.create_from_config_file`, CLI wiring, tests, and documentation.)*

## Priority 9: Scripted Demo Worldbuilding
- [x] Plan an expanded narrative arc that showcases branching paths, inventory gating, and optional side objectives. *(Documented in the "Planned Narrative Expansion" section of `docs/data_driven_scenes.md`.)*
  - [x] Sketch a location graph covering at least three distinct regions plus connecting transitional scenes.
  - [x] Identify key items, puzzle locks, and narrative beats that can be expressed purely through the JSON schema.
  - [x] Extend `src/textadventure/data/scripted_scenes.json` with the new regions, ensuring consistent descriptions, commands, and transitions. *(Introduced a post-observatory resonant bridge and sky sanctum finale to round out the storyline.)*
  - [x] Add region hubs for the Sunken Bastion and Aether Spire that connect the planned scene graph.
  - [x] Populate optional detours (`scavenger-camp`, `ranger-lookout`, side rooms) with unique interactions and returns.
  - [x] Gate at least one transition on collected items to set up later objectives.
  - [x] Ensure the lore guide includes entries for newly introduced locations or key items.
  - [x] Update automated tests so expectations match the broadened content.
  - [x] Update documentation if new commands, items, or mechanics are introduced.
  - [x] Capture notes about additional engine support needed for future iterations.
    - [x] Follow-up: Explore conditional narration hooks (beyond inventory checks) for future scripted-engine enhancements.
      - [x] Define JSON schema and engine support for conditional narration triggers.
      - [x] Update the scripted engine to evaluate the new conditions and record custom events when triggered.
      - [x] Extend the bundled scene data with at least one conditional narration example.
      - [x] Cover the new behaviour with automated tests.
      - [x] Document the data format updates for adventure authors.
  - [x] Flesh out the `starting-area` branches leading to the scavenger camp and lookout tutorials.
  - [x] Author narrative beats for the Sunken Bastion hub scenes.
  - [x] Define the Aether Spire ascent and finale scaffolding.
  - [x] Review lore flavour interactions to highlight journal and memory hooks.
  - [x] Validate the expanded scene data for structural errors and fix any inconsistencies discovered.
    - [x] Correct the malformed `look` transition formatting in the `collapsed-hall` scene.
  - [x] Mark the original checklist item complete once all subtasks pass review.
- [x] Update scripted-engine tests and fixtures to cover the expanded scene graph and any new command patterns.
  - [x] Add regression coverage validating transition targets, required items, and failure messages for gated actions. *(Added targeted tests for the ranger signal gate, flooded archives study requirement, and related success flows.)*
  - [x] Add coverage for the new `journal` and `inventory` command summaries. *(Added tests asserting history truncation and alphabetised inventory listings.)*
- [x] Refresh golden transcripts (if any) so the CLI demo walkthrough exercises the broader storyline. *(Captured an updated CLI walkthrough transcript and regression test to cover the expanded regions.)*
- [x] Document the enhanced demo in `docs/data_driven_scenes.md`, including a high-level map, quest summaries, and authoring tips for further expansion. *(Added an "Expanded Demo Reference" section summarising regions, quest flow, and future authoring guidance.)*

## Priority 10: Browser-Based Scene Editor
- [ ] Design and implement a comprehensive web-based GUI for editing and extending scene data to make adventure authoring accessible to non-programmers.
  - [ ] **Phase 1: Foundation & Backend API**
    - [x] Analyze current JSON schema and identify all data relationships (scenes, transitions, items, conditions). *(Documented the existing runtime model in `docs/web_editor_schema.md` to guide the web editor API design.)*
    - [x] Design RESTful API specification for scene CRUD operations. *(Documented in `docs/web_editor_api_spec.md`.)*
    - [ ] Implement FastAPI backend with the following endpoints:
      - [x] `GET /api/scenes` - List all scenes with metadata *(Implemented read-only endpoint backed by the scripted scene store, including pagination, filtering, and validation summaries.)*
      - [x] `GET /api/scenes/{scene_id}` - Get detailed scene data *(Implemented read-only detail endpoint returning full scene definitions with optional validation metadata.)*
      - [ ] `PUT /api/scenes/{scene_id}` - Update existing scene
      - [ ] `POST /api/scenes` - Create new scene
      - [ ] `DELETE /api/scenes/{scene_id}` - Delete scene (with dependency checks)
      - [x] `GET /api/scenes/validate` - Full integrity validation *(Added read-only endpoint returning quality, reachability, and item-flow summaries with test coverage.)*
      - [ ] `GET /api/scenes/graph` - Scene connectivity graph data
      - [ ] `POST /api/scenes/import` - Import JSON scene data
      - [ ] `GET /api/scenes/export` - Export current scenes as JSON
    - [ ] Add comprehensive validation engine:
      - [ ] Scene reference integrity (no broken targets)
      - [ ] Item flow analysis (sources vs requirements)
      - [ ] Reachability analysis (unreachable scenes/items)
      - [ ] Circular dependency detection
      - [ ] Command uniqueness validation
    - [ ] Implement WebSocket endpoint for live adventure testing.
    - [ ] Add unit tests covering all API endpoints and validation logic.
    - [ ] Document API specification with OpenAPI/Swagger.

  - [ ] **Phase 2: Core Frontend Architecture**
    - [ ] Set up React application with TypeScript for type safety.
    - [ ] Configure build pipeline (Vite/Webpack) with development server.
    - [ ] Implement responsive CSS framework (Tailwind CSS or Material-UI).
    - [ ] Create base component library:
      - [ ] Layout components (headers, sidebars, panels)
      - [ ] Form components (inputs, selects, textareas)
      - [ ] Data display components (tables, cards, badges)
      - [ ] Navigation components (breadcrumbs, tabs)
    - [ ] Set up state management (Redux Toolkit or Zustand).
    - [ ] Implement API client with proper error handling and loading states.
    - [ ] Add routing system for different editor views.

  - [ ] **Phase 3: Scene List & Basic Editing**
    - [ ] Implement scene list view:
      - [ ] Searchable/filterable scene table
      - [ ] Scene metadata display (description preview, choice count, transition count)
      - [ ] Quick actions (edit, duplicate, delete)
      - [ ] Validation status indicators (errors, warnings)
    - [ ] Create basic scene editor form:
      - [ ] Scene ID and description editing
      - [ ] Dynamic choice list editor (add/remove/reorder)
      - [ ] Basic transition editor (target selection, narration)
      - [ ] Real-time validation feedback
      - [ ] Auto-save functionality
    - [ ] Implement scene creation wizard:
      - [ ] Template selection (empty, copy from existing)
      - [ ] Guided setup for basic properties
      - [ ] Integration with scene list
    - [ ] Add scene deletion with dependency checking:
      - [ ] Show which scenes reference the target
      - [ ] Confirmation dialog with impact analysis
      - [ ] Safe deletion that updates references

  - [ ] **Phase 4: Visual Scene Graph**
    - [ ] Integrate React Flow library for interactive graph visualization.
    - [ ] Implement scene node components:
      - [ ] Color-coded by type (start, end, branch, linear)
      - [ ] Validation status indicators (error, warning, valid)
      - [ ] Hover tooltips with scene metadata
      - [ ] Click to open editor
    - [ ] Implement transition edge components:
      - [ ] Different styles for different transition types
      - [ ] Conditional edges (requirements) shown differently
      - [ ] Edge labels showing command names
      - [ ] Click to edit transition
    - [ ] Add graph interaction features:
      - [ ] Drag-and-drop scene positioning
      - [ ] Zoom and pan controls
      - [ ] Minimap for large graphs
      - [ ] Auto-layout algorithms
      - [ ] Search and focus on specific scenes
    - [ ] Implement dependency highlighting:
      - [ ] Highlight item flow chains
      - [ ] Show unreachable scenes in red
      - [ ] Trace paths between scenes
      - [ ] Critical path analysis

  - [ ] **Phase 5: Advanced Editing Features**
    - [ ] Create comprehensive transition editor:
      - [ ] Target scene dropdown with autocomplete
      - [ ] Rich text editor for narration
        - [ ] Evaluate rich text frameworks that output Markdown-compatible content
        - [x] Document requirements and integration plan *(see `docs/rich_text_editor_plan.md`)*
        - [x] Prototype Markdown rendering in the CLI runtime *(Added ANSI Markdown renderer and wired it into the CLI formatting flow.)*
        - [ ] Integrate the editor into the scene authoring UI shell
        - [ ] Add collaborative enhancements (presence indicators, inline comments)
      - [ ] Item requirements multi-select
      - [ ] Item consumption configuration
      - [ ] Failure narration editor
      - [ ] Conditional logic builder
    - [ ] Implement choice matrix editor:
      - [ ] Grid view of all choices across scenes
      - [ ] Bulk editing capabilities
      - [ ] Command standardization tools
      - [ ] Consistency checking
    - [ ] Build conditional logic visual editor:
      - [ ] Drag-and-drop condition builder
      - [ ] Support for `requires_history_any/all`
      - [ ] Visual representation of complex conditions
      - [ ] Testing interface for conditions
    - [ ] Add item flow analyzer:
      - [ ] Visual item dependency graph
      - [ ] Source tracking (where items come from)
      - [ ] Usage tracking (where items are required)
      - [x] Orphaned item detection *(Implemented analytics helpers and CLI reporting for orphaned/unsourced items.)*
      - [x] Item balance analysis *(Added award/consumption balance classification and reporting.)*

  - [ ] **Phase 6: Live Preview & Testing**
    - [ ] Implement embedded adventure player:
      - [ ] Real-time scene rendering
      - [ ] Interactive choice selection
      - [ ] State tracking (location, inventory, history)
      - [ ] Reset and restart capabilities
    - [ ] Create testing toolkit:
      - [x] State manipulation tools (set inventory, history). *(Introduced `testing_toolkit` helpers for resetting inventory and history with regression tests.)*
      - [x] Jump to specific scenes *(Added `jump_to_scene` helper for quickly moving the world state during tests with optional history recording.)*
      - [x] Debug mode showing internal state *(Introduced `debug_snapshot` helper returning a structured `WorldDebugSnapshot` for assertions.)*
      - [x] Step-by-step execution *(Added `step_through` helper and tests for scripted command execution with memory tracking.)*
    - [ ] Add WebSocket integration for live updates:
      - [ ] Real-time scene updates in preview
      - [ ] Collaborative editing indicators
      - [ ] Change broadcasting
    - [ ] Implement playtesting features:
      - [ ] Session recording and replay
      - [ ] Path tracking and analytics
      - [ ] Playtester feedback collection
      - [ ] A/B testing for narrative variants

  - [ ] **Phase 7: Import/Export & File Management**
    - [ ] Build robust JSON import system:
      - [ ] File upload with validation
      - [ ] Schema migration support
      - [ ] Conflict resolution (merge vs replace)
      - [ ] Backup creation before import
    - [ ] Implement export options:
      - [ ] Full scene export
      - [ ] Selective scene export
      - [ ] Minified vs pretty-printed JSON
      - [ ] Backup and versioning
    - [ ] Add version control integration:
      - [ ] Git-style change tracking
      - [ ] Diff visualization
      - [ ] Rollback capabilities
      - [ ] Branch management for different storylines
    - [ ] Create project management features:
      - [ ] Multiple adventure projects
      - [ ] Project templates
      - [ ] Asset organization
      - [ ] Collaborative permissions

  - [ ] **Phase 8: Quality of Life & Polish**
    - [ ] Implement comprehensive search:
      - [x] Global text search across all scenes *(Added search utilities and API endpoint for querying scene text with highlighted spans.)*
      - [x] Advanced filters (by type, validation status, etc.) *(Search utilities now support field/scene filters and the API accepts comma-separated field type and validation filters with regression coverage.)*
        - [x] Extend search utilities to support field-type and scene filters
        - [x] Surface field-type filtering in the API/search endpoint
        - [x] Add validation-status filtering support via the API
        - [x] Expand tests covering the new filtering capabilities
      - [x] Search and replace functionality *(Added in-place scene text replacement utilities with automated coverage.)*
      - [x] Reference finding *(Implemented structured reference detection utilities with filtering and regression coverage.)*
        - [x] Define reference categories for scenes, items, and history usage.
        - [x] Implement utilities to locate structured references with optional filters.
        - [x] Add regression tests covering reference detection scenarios.
    - [ ] Add keyboard shortcuts and accessibility:
      - [ ] Common action shortcuts
      - [ ] Tab navigation
      - [ ] Screen reader support
      - [ ] High contrast mode
    - [ ] Create help system:
      - [ ] Interactive tutorials
      - [x] Context-sensitive help *(Added a CLI `help` command that surfaces current story choices alongside system command guidance.)*
      - [x] Best practices guide *(Documented adventure design guidance in `docs/best_practices.md` and linked it from the README.)*
      - [x] Troubleshooting documentation *(Added `docs/troubleshooting.md` and linked it from the README troubleshooting section.)*
    - [ ] Implement data analytics:
      - [x] Adventure complexity metrics
        - [x] Define core metrics to compute for scripted scene collections.
        - [x] Implement metrics utilities with automated tests.
        - [x] Provide a CLI/report helper for summarising the results.
      - [x] Reachability statistics *(Reachability analysis utilities, CLI reporting, and regression coverage implemented.)*
        - [x] Add analytics helpers to compute reachable and unreachable scenes from a starting location.
        - [x] Surface a formatted reachability report alongside the existing complexity output.
        - [x] Cover the new helpers with automated tests against sample scenes.
      - [x] Content distribution analysis *(Added word/character distribution metrics across scenes, choices, transitions, failure narrations, and conditional overrides with CLI reporting.)*
      - [x] Quality assessment tools
        - [x] Define heuristics for identifying low-quality scene content.
        - [x] Implement quality assessment reporting utilities and CLI output.
        - [x] Cover the new quality checks with automated tests.

  - [ ] **Phase 9: Integration & Deployment**
    - [ ] Integrate editor with existing CLI workflow:
      - [ ] File watching for automatic reloads
      - [ ] CLI command to launch editor
      - [ ] Development mode integration
    - [ ] Create deployment pipeline:
      - [ ] Docker containerization
      - [ ] Environment configuration
      - [ ] Production build optimization
      - [ ] Static asset management
    - [ ] Add authentication and user management:
      - [ ] User accounts and profiles
      - [ ] Project sharing and permissions
      - [ ] Collaborative editing features
      - [ ] Access control
    - [ ] Implement backup and recovery:
      - [ ] Automatic backups
      - [ ] Cloud storage integration
      - [ ] Disaster recovery procedures
      - [ ] Data export for migration

  - [ ] **Phase 10: Documentation & Community**
  - [ ] Create comprehensive user documentation:
      - [x] Getting started guide *(Added `docs/getting_started.md` with step-by-step setup, quality gates, and troubleshooting tips, and linked it from the README.)*
      - [x] Feature reference *(Documented key capabilities in `docs/feature_reference.md` and linked the overview from the README.)*
      - [x] Advanced techniques *(Documented power-user workflows in `docs/advanced_techniques.md` and linked them from the README.)*
      - [x] Troubleshooting guide *(Expanded `docs/troubleshooting.md` with setup checks, tool diagnostics, and cross-references to related documentation.)*
    - [ ] Build developer documentation:
      - [x] API reference *(Documented key runtime modules in `docs/api_reference.md`.)*
      - [x] Extension guide *(Documented developer extension patterns in `docs/extension_guide.md` and linked it from the README.)*
      - [x] Contributing guidelines *(Added `docs/contributing.md` outlining the development workflow, quality gates, and review expectations.)*
      - [x] Architecture overview *(Documented the module layout and extension points in `docs/architecture_overview.md`.)*
    - [ ] Establish community features:
      - [ ] Scene sharing marketplace
      - [ ] Community templates
      - [ ] Rating and review system
      - [ ] Discussion forums
